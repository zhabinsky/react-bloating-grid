"use strict";var _react=require("react");Object.defineProperty(exports,"__esModule",{value:!0}),exports["default"]=void 0;function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(arr,i){if(Symbol.iterator in Object(arr)||"[object Arguments]"===Object.prototype.toString.call(arr)){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!(i&&_arr.length===i));_n=!0);}catch(err){_d=!0,_e=err}finally{try{_n||null==_i["return"]||_i["return"]()}finally{if(_d)throw _e}}return _arr}}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}/**
 * Is used to discover which grid element is hovered over
 * 
 * @param {String} elementId 
 * @param {Object} sizes
 */var useSelectedBox=function(elementId,gridColumns,gridColumnGap,gridRowGap,childrenLength){var _useState=(0,_react.useState)(-1),_useState2=_slicedToArray(_useState,2),selected=_useState2[0],setSelected=_useState2[1],reset=function(){return setSelected(-1)};return[selected,function onMouseMove(e){e.persist();var _getOffset=getOffset(elementId),_getOffset2=_slicedToArray(_getOffset,2),offsetX=_getOffset2[0],offsetY=_getOffset2[1],clientX=e.clientX,clientY=e.clientY,selectedNext=getSelectedElement(clientX-offsetX,clientY-offsetY,elementId,gridColumns,gridColumnGap,gridRowGap);return selectedNext===selected?void 0:childrenLength<=selectedNext?reset():void setSelected(selectedNext)},reset]},getSelectedElement=function(x,y,elementId,gridColumns,gridColumnGap,gridRowGap){// Figuring out width and height of a grid element
// By taking the first child from this #elementId
var height,width,element=document.querySelector("#".concat(elementId," > div"));if(element){var positionInfo=element.getBoundingClientRect();height=positionInfo.height,width=positionInfo.width}else height=1,width=1;var c=x/(width+gridColumnGap),r=y/(height+gridRowGap);return Math.max(Math.floor(r)*gridColumns+Math.floor(c),-1)},_default=useSelectedBox;exports["default"]=_default;var getOffset=function(elementId){var el=document.querySelector("#".concat(elementId));if(!el)return[0,0];var rect=el.getBoundingClientRect();return[rect.left,rect.top]};// Functionality that allows to exclude the gap between elements
// TODO: decide if you want to keep it
// if (config.excludeGap) {
//   /** Selected box index is -1 when pointing to a gap */
//   if (1 - (c - Math.floor (c)) < gridColumnGap / cellW) selectedBox = -1;
//   else if (1 - (r - Math.floor (r)) < gridRowGap / cellH) selectedBox = -1;
// }